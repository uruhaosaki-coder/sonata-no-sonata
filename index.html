<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>そなたのソナタ</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            font-family: "Inter", sans-serif;
            scroll-behavior: smooth;
        }
        
        /* 選択中のボタンスタイル (通常のCSS) */
        .track-button.selected {
            background-color: #D3C34A; /* 黄色 */
            color: #1B2A5C;            /* 濃い青文字 */
            border: 4px solid #fde68a; /* ring-yellow-200 の代わり */
            font-weight: bold;
            padding-top: 1rem;
            padding-bottom: 1rem;
            padding-left: 0.5rem;
            padding-right: 0.5rem;
        }
    </style>
</head>
<!-- 背景を #717071 (グレー) に変更 -->
<body class="bg-[#717071] flex items-center justify-center min-h-screen p-4">

    <!-- カードの背景色を #1B2A5C (濃い青) に変更 -->
    <div class="w-full max-w-2xl bg-[#1B2A5C] rounded-lg shadow-xl p-6">
        <!-- タイトルの文字色を #D3C34A (黄色) に変更 -->
        <h1 class="text-2xl font-bold text-center text-[#D3C34A] mb-6">そなたのソナタ</h1>

        <!-- トラック選択ボタン (8曲用にレイアウト変更) -->
        <!-- sm:grid-cols-3 (3列) -> 変更なし -->
        <!-- md:grid-cols-5 (5列) -> md:grid-cols-4 (4列) に変更 -->
        <div id="button-container" class="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 gap-4 mb-6 w-full">
            <template id="track-button-template">
                <!-- Trackボタン: 白背景(bg-white)、青文字(text-[#1B2A5C]) -->
                <button class="track-button text-[#1B2A5C] font-bold py-4 px-2 rounded-lg bg-white hover:bg-gray-100 transition-all duration-200 shadow-md text-sm border-4 border-transparent">
                    Track
                </button>
            </template>
        </div>

        <!-- 操作ボタン -->
        <div class="flex space-x-4">
            <button id="play-button" class="flex-1 bg-green-500 hover:bg-green-600 text-white font-bold py-4 px-6 rounded-lg text-lg shadow-lg transition duration-300">
                再生
            </button>
            <button id="stop-button" class="flex-1 bg-red-500 hover:bg-red-600 text-white font-bold py-4 px-6 rounded-lg text-lg shadow-lg transition duration-300">
                停止
            </button>
        </div>

        <!-- ステータス表示 (明るいグレー) -->
        <div id="status" class="text-center text-gray-300 mt-4 h-6"></div>
    </div>

    <script>
        // --- ▼ 音源設定 (GitHub Pagesアップロード用) ▼ ---
        
        // !【重要】このファイルは GitHub Pages にアップロードするためのものです。
        // ! このまま「プレビュー」しても "ファイルが見つからない" というエラーになりますが、
        // ! これは正常な動作です。
        
        // !【警告】 'a.m4a' などの .m4a 形式のファイルは、多くのブラウザで再生エラーになります。
        // ! もし GitHub Pages で音が鳴らない場合は、
        // ! 必ず音源を .mp3 形式または .wav 形式に変換し、
        // ! ここのファイル名も "a.mp3" や "a.wav" などに修正してください。

        // 再生開始時に鳴る音 (i.wav に変更)
        const A_URL = "i.wav";

        // 再生終了時に鳴る音 (i.wav に変更)
        const B_URL = "i.wav";

        // 選択する8種類の音トラック (8曲に変更, .wav に変更)
        const TRACK_URLS = [
            "track1.wav", // Track 1
            "track2.wav", // Track 2
            "track3.wav", // Track 3
            "track4.wav", // Track 4
            "track5.wav", // Track 5
            "track6.wav", // Track 6
            "track7.wav", // Track 7
            "track8.wav"  // Track 8
        ];
        // --- ▲ 音源設定 ▲ ---


        // Audioオブジェクトのインスタンス (使い回します)
        const audioA = new Audio();
        const audioB = new Audio();
        const audioMain = new Audio(); // シーケンス再生用
        const audioPreview = new Audio(); // プレビュー再生専用
        
        let currentSequence = []; // 再生シーケンスのキュー
        let currentPlayingAudio = null; // 現在再生中のAudioオブジェクト (シーケンス用)
        let currentPreviewAudio = null; // 現在プレビュー中のAudioオブジェクト

        // DOM要素
        const buttonContainer = document.getElementById('button-container');
        const playButton = document.getElementById('play-button');
        const stopButton = document.getElementById('stop-button');
        const statusEl = document.getElementById('status');
        const template = document.getElementById('track-button-template');

        let selectedTrackIndex = 0; // デフォルトでTrack 1 (インデックス 0) を選択
        let trackButtons = []; // ボタンの参照を保持する配列

        // --- 初期化 ---
        
        // このif文は、<template> タグが正しく読み込まれたか確認するためのものです
        if (template && buttonContainer) {
            // トラックボタンを生成
            TRACK_URLS.forEach((url, index) => {
                const clone = template.content.cloneNode(true);
                const button = clone.querySelector('.track-button');
                
                button.textContent = `Track ${index + 1}`;
                button.dataset.index = index; 

                button.addEventListener('click', () => {
                    // トラックボタンクリックでプレビュー再生
                    playPreview(index);
                });

                buttonContainer.appendChild(clone);
                trackButtons.push(button); 
            });
        } else {
            console.error("初期化エラー: button-container または track-button-template が見つかりません。");
            statusEl.textContent = "ボタンの初期化に失敗しました";
        }


        // トラックの選択状態（色）だけを更新する
        function updateButtonSelection(index) {
            selectedTrackIndex = index;
            trackButtons.forEach((btn, i) => {
                // 'selected' クラス (黄色の背景) の付け外し
                btn.classList.toggle('selected', i === index);
            });
        }
        
        // 起動時にデフォルト（Track 1）を選択状態にする (音は鳴らさない)
        // trackButtonsが正しく生成された場合のみ実行
        if (trackButtons.length > 0) {
            updateButtonSelection(0);
        }


        // --- 再生ロジック ---

        playButton.addEventListener('click', playSequence);
        stopButton.addEventListener('click', stopAllAudio);

        // トラックボタン（プレビュー）のロジック
        function playPreview(index) {
            // まずは選択状態（色）を更新
            updateButtonSelection(index);

            // もし同じトラックがすでにプレビュー再生中なら、停止する
            if (currentPreviewAudio && currentPreviewAudio.dataset.index == index && !currentPreviewAudio.paused) {
                currentPreviewAudio.pause();
                currentPreviewAudio.currentTime = 0;
                currentPreviewAudio = null;
                statusEl.textContent = `Track ${index + 1} プレビュー停止`;
                return;
            }

            // 他の音（シーケンスまたはプレビュー）をすべて停止
            stopAllAudio(true); // true = プレビュー停止中であることを示す

            const url = TRACK_URLS[index];
            currentPreviewAudio = audioPreview; // プレビュー用のAudioオブジェクトを使用
            currentPreviewAudio.src = url;
            currentPreviewAudio.dataset.index = index; // どのトラックか記録

            currentPreviewAudio.removeEventListener('ended', previewEnded);
            currentPreviewAudio.removeEventListener('error', handleAudioError);

            currentPreviewAudio.addEventListener('ended', previewEnded);
            currentPreviewAudio.addEventListener('error', (e) => handleAudioError(e, `Preview Track ${index + 1}`));
            
            statusEl.textContent = `Track ${index + 1} をプレビュー中...`;
            console.log(`Playing Preview ${index + 1} (URL: ${url})`);
            
            currentPreviewAudio.play().catch(e => {
                console.error(`Playback error (Preview ${index + 1}):`, e.message);
                statusEl.textContent = `再生エラー (Preview)`;
            });
        }

        function previewEnded() {
            statusEl.textContent = "プレビュー終了";
            currentPreviewAudio = null;
        }

        // 再生ボタン（シーケンス）のロジック
        function playSequence() {
            // 他の音（プレビューなど）をすべて停止
            stopAllAudio(); 
            
            currentSequence = [
                { audio: audioA, url: A_URL, name: "A (i.wav)" },
                { audio: audioMain, url: TRACK_URLS[selectedTrackIndex], name: "Main" },
                { audio: audioB, url: B_URL, name: "B (i.wav)" }
            ];
            
            playNextInSequence();
        }

        function playNextInSequence() {
            if (currentSequence.length === 0) {
                console.log("Sequence finished");
                statusEl.textContent = "再生終了";
                currentPlayingAudio = null;
                return;
            }

            const next = currentSequence.shift();
            currentPlayingAudio = next.audio;

            currentPlayingAudio.removeEventListener('ended', playNextInSequence);
            currentPlayingAudio.removeEventListener('error', handleAudioError);
            
            currentPlayingAudio.src = next.url;
            
            currentPlayingAudio.addEventListener('ended', playNextInSequence);
            currentPlayingAudio.addEventListener('error', (e) => handleAudioError(e, next.name));

            statusEl.textContent = `${next.name === 'Main' ? 'Track ' + (selectedTrackIndex + 1) : next.name} を再生中...`;
            console.log(`Playing ${next.name} (URL: ${next.url})`);
            
            currentPlayingAudio.play().catch(e => {
                console.error(`Playback error (${next.name}):`, e.message);
                statusEl.textContent = `再生エラー (${next.name})`;
                playNextInSequence(); // エラーが起きても次のシーケンスに進む
            });
        }

        // エラーハンドリング
        function handleAudioError(e, name) {
            console.error(`Audio Playback Error (${name}):`, e);
            statusEl.textContent = `エラー (${name}): ファイル読込失敗`;
            // シーケンス再生中のエラーなら、次のシーケンスに進む
            if (name.startsWith('A') || name.startsWith('Main') || name.startsWith('B')) {
                playNextInSequence();
            }
        }

        // 停止ボタン（すべて停止）のロジック
        function stopAllAudio(isPreviewStop = false) {
            // シーケンス再生を停止
            [audioA, audioB, audioMain].forEach(audio => {
                if (audio) {
                    audio.pause();
                    audio.currentTime = 0;
                    audio.removeEventListener('ended', playNextInSequence);
                    audio.removeEventListener('error', handleAudioError);
                }
            });
            currentSequence = []; 
            currentPlayingAudio = null;

            // プレビュー再生を停止
            if (audioPreview) {
                audioPreview.pause();
                audioPreview.currentTime = 0;
                audioPreview.removeEventListener('ended', previewEnded);
                audioPreview.removeEventListener('error', handleAudioError);
            }
            currentPreviewAudio = null;
            
            if (!isPreviewStop) { // プレビュー停止（内部呼び出し）の時はメッセージを変えない
                statusEl.textContent = "停止しました";
            }
            console.log("All audio stopped");
        }
    </script>
</body>
</html>
